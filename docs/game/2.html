<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>创建一个动画对象 | João&#39;s 博客</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="https://murongqimiao.github.iojoaoBlog/assets/css/0.styles.f5338f93.css" as="style"><link rel="preload" href="https://murongqimiao.github.iojoaoBlog/assets/js/app.abcac223.js" as="script"><link rel="preload" href="https://murongqimiao.github.iojoaoBlog/assets/js/2.251005b6.js" as="script"><link rel="preload" href="https://murongqimiao.github.iojoaoBlog/assets/js/8.fe0aa8c8.js" as="script"><link rel="prefetch" href="https://murongqimiao.github.iojoaoBlog/assets/js/10.e8d1ccd8.js"><link rel="prefetch" href="https://murongqimiao.github.iojoaoBlog/assets/js/11.ebd2c6cd.js"><link rel="prefetch" href="https://murongqimiao.github.iojoaoBlog/assets/js/12.f1e85e0c.js"><link rel="prefetch" href="https://murongqimiao.github.iojoaoBlog/assets/js/13.82f017ad.js"><link rel="prefetch" href="https://murongqimiao.github.iojoaoBlog/assets/js/14.17657132.js"><link rel="prefetch" href="https://murongqimiao.github.iojoaoBlog/assets/js/15.2d7032ce.js"><link rel="prefetch" href="https://murongqimiao.github.iojoaoBlog/assets/js/16.f0a1d6b5.js"><link rel="prefetch" href="https://murongqimiao.github.iojoaoBlog/assets/js/3.b8aa1093.js"><link rel="prefetch" href="https://murongqimiao.github.iojoaoBlog/assets/js/4.3381d699.js"><link rel="prefetch" href="https://murongqimiao.github.iojoaoBlog/assets/js/5.318d90a7.js"><link rel="prefetch" href="https://murongqimiao.github.iojoaoBlog/assets/js/6.1de5244e.js"><link rel="prefetch" href="https://murongqimiao.github.iojoaoBlog/assets/js/7.ce829ba3.js"><link rel="prefetch" href="https://murongqimiao.github.iojoaoBlog/assets/js/9.4ddcb1c2.js">
    <link rel="stylesheet" href="https://murongqimiao.github.iojoaoBlog/assets/css/0.styles.f5338f93.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">João's 博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link router-link-active">
  Home
</a></div><div class="nav-item"><a href="/" class="nav-link">
  Guide
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link router-link-active">
  Home
</a></div><div class="nav-item"><a href="/" class="nav-link">
  Guide
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/" aria-current="page" class="sidebar-link">首页</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/dag" class="sidebar-heading clickable"><span>DAG-Diagram有向无环图</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/game" class="sidebar-heading clickable router-link-active open"><span>可交互帧动画游戏</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/game/" aria-current="page" class="sidebar-link">开篇</a></li><li><a href="/game/0.html" class="sidebar-link">初始环境构建</a></li><li><a href="/game/1.html" class="sidebar-link">创建一个游戏对象</a></li><li><a href="/game/2.html" aria-current="page" class="active sidebar-link">创建一个动画对象</a></li><li><a href="/game/3.html" class="sidebar-link">添加动画对象的控制逻辑</a></li><li><a href="/game/4.html" class="sidebar-link">地图加载</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="创建一个动画对象"><a href="#创建一个动画对象" class="header-anchor">#</a> 创建一个动画对象</h1> <p>代码参考 joaoStudio master分支 lesson2 文件夹</p> <div class="language- extra-class"><pre class="language-text"><code>npm start 启动后
可以在页面中看到一个冒险岛红色飞侠角色出现在页面中, 有默认呼吸动作
</code></pre></div><p><img src="https://murongqimiao.github.iojoaoBlog/assets/img/2-0.49e69f57.gif" alt="2-0.gif"></p> <p>目录结构</p> <div class="language- extra-class"><pre class="language-text"><code>  | -- package.json
  | -- webpack.config.js
  | 
  | -- src
     | -- assets
        | --  role                   ·······················存放角色相关图像资源

     | -- data
        | --  common                 ·······················通用数据
        | --  role                   ·······················角色相关信息
    
     | -- utils
        | -- canvasTool        ·······················      绘制功能抽离
        | -- collisionDetection  ·······················    碰撞检测
        | -- handleImage       ······················       生成帧动画的逻辑
        | -- positionReset    ··························    坐标计算
        | -- resources        ··························    资源加载
     | --  index.js
     | --  index.html
</code></pre></div><p>这次添加了新的文件夹,用来存放静态资源,所以webpack config js文件夹需要更改配置</p> <ol><li>添加patterns配置, 增加assets文件夹的复制</li> <li>增加了url-loader, 用来加载图片, limit配置成1, 我们不需要把图片转成base64打进js包, 图片太多导致包体积过大了</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const path = require('path')
const CopyWebpackPlugin = require('copy-webpack-plugin');

module.exports = {
    mode: 'development',
    entry: path.resolve('./src/'),
    output: {
        path: path.resolve('./dist'),
        filename: 'index.js',
        pathinfo: true
    },
    module: { // 静态资源引入图片 加上webpack url-loader解释器
        rules: [{
            test: /.(jpg|png)$/,
            use: {
              loader: 'url-loader',
              options: {
                limit: 1,
              }
            }
        }],
    },
    plugins: [
        new CopyWebpackPlugin({
            patterns: [{
                from: &quot;./src/index.html&quot;, to: &quot;./index.html&quot;
            }, {
                from: &quot;./srchttps://murongqimiao.github.iojoaoBlog/assets&quot;, to: &quot;.https://murongqimiao.github.iojoaoBlog/assets&quot;
            }]
        })
    ]
};
</code></pre></div><p>然后在index.js文件中添加一个Role 的class类, 这个类帮助我们生成动画对象
关于动画对象
一个完整的动画对象包括</p> <ol><li>状态</li> <li>curEvent 记录当前应该执行什么行为, 用什么图片来渲染</li> <li>frameInfo 动画对象可以执行的全部动画内容</li> <li>position  动画对象要渲染在游戏里的哪个位置</li> <li>render    渲染流程, 根据curEvent把需要渲染的动画取出并且渲染到指定位置的逻辑</li></ol> <div class="language- extra-class"><pre class="language-text"><code>class Role {
    state = {}
    skill = {}
    position = {}
    curEvent = null // 记录当前执行的事件
    zIndex = 1 // 渲染的层级
    curRender = {
        imgClass: null,
        imgLR: null,
        curFrameImgIndex: 0,
        curFrame: 0,
    } // 记录当前渲染内容
    constructor(props) {
        this.state = JSON.parse(JSON.stringify(props.state))
        this.skill = props.skill
        this.onAdded = props.onAdded || null
        this.onDead = props.onDead || null
        this.onCrash = props.onCrash || null
        this.framesList = props.framesList || {}
        this.zIndex = props.zIndex || 1
    }
    addPosition(params) {
        const { x, y, z = 0, yRegression = 0 } = params;
        if (!this.position.x) {
            this.oldPosition = JSON.parse(JSON.stringify({ x, y, z, yRegression }))
        } else {
            this.oldPosition = JSON.parse(JSON.stringify(this.position))
        }
        this.position =  { x, y, z, yRegression }
        return this;
    }
    // 渲染逻辑 找到指定的某个图片 某一帧  渲染到canvas里
    render() {
        const { ctx, debug } = arguments[0]
        let curRenderBother = null
        if (this.curEvent &amp;&amp; this.framesList[this.curEvent]) {
            const frameList = this.framesList[this.curEvent]
            let { curFrameImgIndex, curFrame } = this.curRender
            // 命中当前行为 进行渲染
            if (curFrame == frameList[curFrameImgIndex].frameStayTime) { // 动画行进到下一张
                if (curFrameImgIndex === frameList.length - 1) { // 重复动画归0
                    // 钩子 执行完动画后, 判断帧动画结束时间是否存在
                    while (this.nextFrameEndEvent &amp;&amp; this.nextFrameEndEvent.length) {
                      this.nextFrameEndEvent.shift()() // 帧动画结束事件 全部执行
                    }
                    if (!this.curRender.cantChangeEvent) {
                        this.curRender.curFrameImgIndex = 0
                        this.curRender.curFrame = 0
                    }
                } else {
                    this.curRender.curFrameImgIndex++
                    this.curRender.curFrame = 0
                }
            }
            // 提取img resource
            curRenderBother = frameList[curFrameImgIndex]
            this.curRender.curFrame++
        }
        let Img = window.resources[curRenderBother.name]
        const xywhs // 体积距离左侧距离顶部高宽及是否刚体
        = {
          x: Number(curRenderBother.volumeInfo.offsetLeft),
          y: Number(curRenderBother.volumeInfo.offsetTop),
          width: Number(curRenderBother.volumeInfo.width),
          height: Number(curRenderBother.volumeInfo.height),
          isSolid: Boolean(this.state.volumeInfo.solid)
        }
        const centerOriginxy // 距离
        = {
          x: Number(curRenderBother.centerOrigin.left),
          y: Number(curRenderBother.centerOrigin.top)
        }
        const imgSize // 图片原始大小
        = {
          x: Img.width,
          y: Img.height
        }
        const offset // 获取原始图片时从图片的哪里开始截取
        = {
          x: Number(curRenderBother._offsetLeft),
          y: Number(curRenderBother._offsetTop),
        }
        const imgRenderStyle // 获取图片渲染到画布中的信息
        = {
          x: Number(curRenderBother.renderStyle.width),
          y: Number(curRenderBother.renderStyle.height),
          transform: curRenderBother.renderStyle.transform
        }
        if (curRenderBother) {
            this.curRender.curFrameInfo = curRenderBother
            
            // const { x, y } = getMainViewportPostion(this.position) // 目前不计算相对地图位置的回归数据
            const { x, y } = this.position

            let renderXInCanvas = Math.round(x - centerOriginxy.x)
            let renderYInCanvas = Math.round(y - centerOriginxy.y)
            try {
              switch(imgRenderStyle.transform) { // 
                case 'turnX': 
                    ctx.save()
                    ctx.translate(renderXInCanvas + imgRenderStyle.x, renderYInCanvas)
                    ctx.scale(-1, 1)
                    ctx.drawImage(Img, offset.x, offset.y,imgSize.x, imgSize.y, 0, 0, imgSize.x, imgSize.y)
                    ctx.restore()
                  break;
                default: ctx.drawImage(Img, offset.x, offset.y,imgSize.x, imgSize.y, renderXInCanvas, renderYInCanvas, imgRenderStyle.x, imgRenderStyle.y)
              }
              if (debug) {
                // 图片描边
                drawPolygon({ ctx, color: '#fff' }, [renderXInCanvas,
                  renderYInCanvas,
                  renderXInCanvas,
                  renderYInCanvas + imgSize.y,
                  renderXInCanvas + imgSize.x,
                  renderYInCanvas + imgSize.y,
                  renderXInCanvas + imgSize.x,
                  renderYInCanvas]);
              }
            } catch (err) {
              console.log(&quot;=========== draw image error ==============&quot;, curRenderBother)
            }

            if (debug) {
                // 体积描边
                const borderData = getBulkBorder(this, xywhs, centerOriginxy, imgSize);
                switch (this.state.volumeInfo.shape) {
                    case 'rectangle':
                        drawPolygon({ ctx }, borderData);
                        break;
                    case 'circle':
                        drawDot({ ctx }, borderData)
                        break;
                    default: () =&gt; { }
                }
                // drawDot({ ctx, color: 'yellow' }, [getMainViewportPostion(this.position).x, getMainViewportPostion(this.position).y, 1] )
                drawDot({ ctx, color: 'yellow' }, [x, y, 1] )
            }
        }

        return this
    }
}
</code></pre></div><p>这里可以看到有红色的框框和白色的框框,以及黄色的圆点。
红色框框是后面用来做体积计算的框框.
白色框框是实际图片的渲染位置,因为是png透明图叠加出来的, 所以知道实际图片大小以方便调试, 黄色圆点是角色在游戏里的坐标, 后面用来做障碍物计算和图层渲染优先级计算。
下面描述图片生成逻辑, 与行为匹配图片进行渲染的流程。</p> <p>首先是图片资源加载到项目中的过程
图片资源想被前端项目使用需要被浏览器加载到项目中
这里采用webpack的require.context 一次性读取assets下的全部png图片, 加一个filter是为了后面的场景转换时的选择性加载
当项目非常庞大时,一定要按需加载才能提升用户体验。
上去就加载十分钟的单页面应用是不会有用户喜欢的。</p> <div class="language- extra-class"><pre class="language-text"><code>export const loadInitResources = (cb, filter) =&gt; {
    let files = require.context(&quot;..https://murongqimiao.github.iojoaoBlog/assets&quot;, true, /\.png/)
    let filesPaths = files.keys()
    if (filter) {
        filesPaths = filter(filter)
    }
    loadImgs(filesPaths, cb)
}

/**
 * 向项目中添加本地图片资源
 */
const loadImgs = (imgList, completeFunc) =&gt; {
    const game = window.__game
    const currentLoadImgs = {}
    let maxNumber = null
    let currentLoadNumber = 0

    game.gameStatus.loading = true // start loading modal

    // start load img
    imgList.forEach(v =&gt; {
        let _img = new Image()
        _img.src = &quot;.https://murongqimiao.github.iojoaoBlog/assets/&quot; + v
        currentLoadImgs[_img.src] = 0
        _img.onload = () =&gt; {
            currentLoadImgs[_img.src] = 1
            maxNumber = Object.keys(currentLoadImgs).length
            currentLoadNumber = Object.keys(currentLoadImgs).map(v =&gt; currentLoadImgs[v]).filter(v =&gt; v).length

            window.resources = Object.assign({}, (window.resources || {}), { [`${v.replaceAll('png', '').replaceAll('.', '').replaceAll('/', '_')}`]: _img })
            
            // update loading status
            game.gameStatus.waitForLoad = maxNumber // total imgs
            game.gameStatus.loadImgs = currentLoadNumber // has load imgs

            // load complete
            if (maxNumber === currentLoadNumber) {
                game.gameStatus.loading = false
                completeFunc()
            }
        }
    })
}
</code></pre></div><p>在图片资源加载的同时,我们要生成动画对象的动作动画匹配。
下面的imgFrameInfo用string来描述每一帧的动画, 采用哪张图片来渲染,这张图片需要从哪里裁切, 经过什么样的变换,渲染要哪个相对位置去。</p> <div class="language- extra-class"><pre class="language-text"><code>
/**
 * 参数参考  name 图片名称 | _offsetLeft 读取取值距离左侧 | _offsetTop 读图距离顶部  | toWidth 绘制时宽 | toHeight 绘制时高 | center x 实际站位点距离图片左侧  | center y 实际站位点距离顶部 | transform 图像变换 | frames 每张图持续几帧
 */

export const imgFrameInfo = {
    // name | _offsetLeft | _offsetTop | toWidth| toHeight | centerLeft | centerTop| transoform  共13项 | frames 每张图持续几帧 | 体积距离左侧 volumeOffsetLeft | 体积距离顶部 volumeOffsetTop | volumeWidth 体积宽  | volumeHeight 体积高
    '2_stand': [
        '_role_001_0_stand_0 | 0 | 0 | 57 | 81 | 29 | 81 | turnX | 9 | 5 | 10 | 47 | 71',
        '_role_001_0_stand_1 | 0 | 0 | 57 | 81 | 29 | 81 | turnX | 9 | 5 | 10 | 47 | 71',
        '_role_001_0_stand_2 | 0 | 0 | 57 | 81 | 29 | 81 | turnX | 9 | 5 | 10 | 47 | 71',
    ],
    '6_stand': [
        '_role_001_0_stand_0 | 0 | 0 | 57 | 81 | 29 | 81 | null | 9 | 0 | 0 | 57 | 81',
        '_role_001_0_stand_1 | 0 | 0 | 57 | 81 | 29 | 81 | null | 9 | 0 | 0 | 57 | 81',
        '_role_001_0_stand_2 | 0 | 0 | 57 | 81 | 29 | 81 | null | 9 | 0 | 0 | 57 | 81',
    ],
    '2_run': [
        '_role_001_6_run_0 | 0 | 0 | 57 | 80 | 29 | 80 | turnX | 9 | 0 | 0 | 57 | 81',
        '_role_001_6_run_1 | 0 | 0 | 57 | 81 | 29 | 80 | turnX | 9 | 0 | 0 | 57 | 81',
        '_role_001_6_run_2 | 0 | 0 | 57 | 80 | 29 | 80 | turnX | 9 | 0 | 0 | 57 | 81',
        '_role_001_6_run_3 | 0 | 0 | 57 | 81 | 29 | 80 | turnX | 9 | 0 | 0 | 57 | 81',
    ],
    '6_run': [
        '_role_001_6_run_0 | 0 | 0 | 57 | 80 | 29 | 80 | null | 9 | 0 | 0 | 57 | 81',
        '_role_001_6_run_1 | 0 | 0 | 57 | 81 | 29 | 80 | null | 9 | 0 | 0 | 57 | 81',
        '_role_001_6_run_2 | 0 | 0 | 57 | 80 | 29 | 80 | null | 9 | 0 | 0 | 57 | 81',
        '_role_001_6_run_3 | 0 | 0 | 57 | 81 | 29 | 80 | null | 9 | 0 | 0 | 57 | 81',
    ]

}

/utils/handleImage.js文件中
/**
 * 生成帧动画列表
 */
export const generateFrameList = function (imageFrameInfoArr) {
    imageFrameInfoArr = imageFrameInfoArr.map((v, index) =&gt; {
        const [name = '', _offsetLeft = 0, _offsetTop = 0, toWidth = 0, toHeight = 0, centerLeft = 0, centerTop = 0, transform = '', frames = '1', volumeOffsetLeft = 0, volumeOffsetTop = 0, volumeWidth = 0, volumeHeight = 0 ] = v.split(' | ')
        // name | _offsetLeft | _offsetTop | toWidth| toHeight | centerLeft | centerTop | volumeShape | transform  共13项 | frames 每张图持续几帧
        return {
            name,
            frameStayTime: frames,
            centerOrigin: {
                left: centerLeft,
                top: centerTop
            },
            _offsetLeft,
            _offsetTop,
            renderStyle: {
                width: toWidth,
                height: toHeight,
                transform: transform,
            },
            volumeInfo: {
                offsetLeft: volumeOffsetLeft,
                offsetTop: volumeOffsetTop,
                width: volumeWidth,
                height: volumeHeight
            }
        }
    })
    return imageFrameInfoArr
}
</code></pre></div><p>然后就把这些数据添加到待渲染的角色信息中
data/role.js文件里存放此类信息</p> <div class="language- extra-class"><pre class="language-text"><code>
export const role01 = {
    state: {
        id: '001',
        name: &quot;主角abc&quot;,
        des: &quot;user control human description&quot;,
        hp: CONSTANT_COMMON.BASE_HERO_HP,
        atk: CONSTANT_COMMON.BASE_HERO_ATK,
        def: CONSTANT_COMMON.BASE_HERO_DEF,
        spd: CONSTANT_COMMON.BASE_HERO_SPD,
        isHero: true,
        maxHp:  CONSTANT_COMMON.BASE_HERO_HP,
        volumeInfo: {
            shape: 'rectangle',
            width: 30,
            height: 80,
            solid: true,
        },
        knapsack: [{
            id: 1,
            number: 0
        }],
        defaultEvent: '2_stand'
    },
    skill: {
        cd: CONSTANT_COMMON.BASE_ONE_SECOND
    },
    zIndex: 10,
    // 图片渲染的优化方向, 提供一个使用大图的高宽及横纵下标返回图片的能力
  
    framesList: {
        '2_stand': generateFrameList(imgFrameInfo['2_stand']),
        '6_stand': generateFrameList(imgFrameInfo['6_stand']),
        '2_run': generateFrameList(imgFrameInfo['2_run']),
        '6_run': generateFrameList(imgFrameInfo['2_run']),
    },
    // 首次添加时执行
    onAdded: function () { 
        const [game, self] = arguments
        self.curEvent = self.state.defaultEvent
    },
    onCrash: function () {
        const [self, crashItem] = arguments
        console.log(&quot;======self=========&quot;, self)
        console.log(&quot;======crashItem=========&quot;, crashItem)
        // if (crashItem.state.isSolid) {
        //     if (self.curRender.lastFrame) {
        //         this.position.x = self.curRender.lastFrame.x1
        //         this.position.y = self.curRender.lastFrame.y1
        //     }
        // }
    }
}
</code></pre></div><p>接下来在index.js里, 我们先加载图片资源, 加载完需要的图片资源后,运行游戏,
实例化一个新的角色类对象,使用addPosition给他一个位置
然后把这个角色对象添加到游戏对象里, 可以看到页面中出现了一个飞侠角色, 在执行default行为, '6_stand'</p> <div class="language- extra-class"><pre class="language-text"><code>let __game = new Game()
window.__game = __game


console.log(&quot;=======role==========&quot;)
console.log(role01)


loadInitResources(() =&gt; {
    console.log(&quot;window.resources&quot;, window.resources)
    __game.start()


    // 添加新的角色进入游戏
    let newRole001 = new Role(role01)
    newRole001.addPosition({ x: 300, y: 400 })
    __game.addNewRole(newRole001)
})

</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/game/1.html" class="prev">
        创建一个游戏对象
      </a></span> <span class="next"><a href="/game/3.html">
        添加动画对象的控制逻辑
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="https://murongqimiao.github.iojoaoBlog/assets/js/app.abcac223.js" defer></script><script src="https://murongqimiao.github.iojoaoBlog/assets/js/2.251005b6.js" defer></script><script src="https://murongqimiao.github.iojoaoBlog/assets/js/8.fe0aa8c8.js" defer></script>
  </body>
</html>
