(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{399:function(t,n,e){t.exports=e.p+"/github.com/murongqimiao/joaoblog/assets/img/1-0.0c49c836.gif"},419:function(t,n,e){"use strict";e.r(n);var i=e(56),o=Object(i.a)({},(function(){var t=this,n=t.$createElement,i=t._self._c||n;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h1",{attrs:{id:"创建一个游戏对象"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#创建一个游戏对象"}},[t._v("#")]),t._v(" 创建一个游戏对象")]),t._v(" "),i("p",[t._v("代码参考 joaoStudio master分支 lesson1 文件夹")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v("npm start 启动后\n可以在页面中看到canvas里运行的helloworld动画\n同时在左上角标出了当前的帧率\n")])])]),i("p",[i("img",{attrs:{src:e(399),alt:"demo"}})]),t._v(" "),i("p",[t._v("所谓可以交互的帧动画,其本质还是帧动画,就是每秒在画布上更新N次图像。")]),t._v(" "),i("p",[t._v("首先要写一个游戏类, class game 来初始化一个全局存在的游戏对象,这个游戏对象每秒会更新自己N次,同时每次更新后都会把最新的数据状态渲染成图像显示在canvas上。")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v('class Game {\n    roleList = []\n    environmentList = [] // 环境资源\n    allRenderList = [] \n    keyCollect = [] // 当前活跃的按键\n    keyCollectBuffer = [] // 活跃过的按键在缓冲区待一阵\n    debug = 1\n    gameFPS = 60\n    currentFrameIndexPerSeconde = 0\n    gameStatus = {\n        loading: false\n    }\n    helloWorldPosition = {\n        x: 0,\n        directionRight: true,\n        y: 0,\n        directionBottom: true\n    }\n\n    /**\n     * 每一帧执行的行为\n     */\n    run() {\n        var c = document.getElementById(\'canvas\');\n        var ctx = c.getContext("2d");\n        // 清理掉原来内容, 重新绘制最新的状态\n        ctx.clearRect(0, 0, c.width, c.height)\n        const that = this;\n\n        // 打印FPS\n        drawFPS(ctx, this.gameFPS)\n\n        // draw helloworld\n        drawHelloWorld(ctx, this.helloWorldPosition)\n\n        // 执行下一帧\n        this.currentFrameIndexPerSeconde++\n        window.requestAnimationFrame(() => {\n            this.run()\n        })\n    }\n\n    getFPS() {\n        this.gameFPS = this.currentFrameIndexPerSeconde\n        this.currentFrameIndexPerSeconde = 0\n        return this\n    }\n\n    start() {\n        console.log("running")\n        console.log(+ new Date())\n        window.requestAnimationFrame(() => {\n            this.run()\n        })\n    }\n\n}\n')])])]),i("p",[t._v("然后添加FPS打印和绘制helloworld的方法")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v("const drawFPS = function (ctx, gameFPS) {\n    ctx.font = '20px Arial'\n    ctx.fillStyle = '#fff'\n    let FPSText = 'FPS:  ' + gameFPS\n    ctx.direction = 'ltr'\n    ctx.fillText(FPSText, 10, 20)\n}\n\nconst drawHelloWorld = function (ctx, position) {\n    const { x, y, directionRight, directionBottom } = position\n    ctx.font = '24px Arial'\n    ctx.fillStyle = '#3072f6'\n    ctx.direction = 'ltr'\n    ctx.fillText('hello world', position.x, position.y)\n    if (directionRight) { position.x += 3 } else { position.x -= 3 }\n    if (directionBottom) { position.y += 1 } else { position.y -= 1 }\n    if (x > 1000) {\n        position.directionRight = false\n    } else if (x < 0) {\n        position.directionRight = true\n    }\n    if (y > 600) {\n        position.directionBottom = false\n    } else if (y < 20) {\n        position.directionBottom = true\n    }\n}\n")])])]),i("p",[t._v("然后实例化一个game类, 运行start方法即可")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v("let _game = new Game()\n_game.start()\n")])])]),i("h1",{attrs:{id:"动态计算帧率"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#动态计算帧率"}},[t._v("#")]),t._v(" 动态计算帧率")]),t._v(" "),i("p",[t._v("因为涉及到性能及高刷屏的问题, requestAnimationFrame每秒稳定运行60帧比较难,所以后续计算要动态考虑当前帧率来计算运动速度等属性。")]),t._v(" "),i("p",[t._v("同时用setTimeout取代requestAnimationFrame是不太合适的, 很多前端知道react16里闲时计算写了两套, 除开requestAnimationFrame还有一套setTimeout, 但是setTimeout很难达到帧率需求。")])])}),[],!1,null,null,null);n.default=o.exports}}]);